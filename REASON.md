# 1차 미션 과정에서 배운점

## REMINDME.md 작성

객체지향적인 코드, 좋은 코드를 작성하기 위해서 배운 점, 또한 이를 위해 주기적으로 열어보고 기억해야 할 사항들을 짧게 정리했습니다.

## 기능 목록 작성 의의

초기에 기능 단위로 구현 리스트를 구분/작성하고, 이를 기반으로 commit하도록 하는 것이 다른 사람에게 코드의 흐름을 자연스럽게 보여줄 수 있을뿐만 아니라, 적절한 추상화와 코드 설계에도 도움을 줄 수 있다는 것을 알 수 있었습니다.

실제 코드를 작성하는 과정에서, 생각했던 요구사항보다 조금 부족하거나 다른 부분이 있었습니다. 이번 미션에서는 단순히 "목표의 나열"에 불과했지만, 더 명확한 책임 식별과 구현 scope를 구분하기 위해 최대한 이를 줄여나가는 것이 중요하다는 것을 배울 수 있었습니다.

## 테스트 코드 작성 의의

이번 미션에서는 TDD 프로세스와 같이 테스트 코드를 먼저 작성하지 않고, 구현을 먼저 하였습니다. 그러다보니 특정 객체에게 요구하는 사항과, 실제 객체가 응답하는 방식이 다른 경우가 있었고, 이는 테스트 코드를 얼마나, 어떻게 작성해야 하는지에 대한 어려움을 야기했습니다.

이번 미션에서 얻은 경험의 반면교사로, 작은 단위부터 출발해서 TDD 사이클을 지키면서 코드를 구현하게 되면 더욱 적절한 책임의 할당이 이루어질 수 있다는 점을 배웠습니다.

# 코드 부연 설명

## BallNumberSet 객체 책임 분할

3개의 중복되지 않는 자료구조를 담는 BallNumberSet 에는 크게 세 가지 역할이 있다고 생각했습니다.

1. 다른 BallNumberSet과 비교하는 것(힌트를 생성하기 위함)
2. 랜덤, 그리고 사용자 입력으로부터 BallNumberSet을 생성하는 것
3. 생성된 BallNumberSet이 유효한 숫자인지 확인하는 것.

1번 역할은, `객체지향의 사실과 오해(조영호 저)` 에서, "객체의 책임은 해당 데이터를 갖고 있는 객체에게 할당하라" 구절을 봤던 기억을 토대로, `BallNumberSet` 자체가 갖고 있는 것이 옳다고 판단했습니다.

2번의 경우, `BallNumberSet` 객체의 생성이 랜덤과 사용자 입력이라는 두 곳으로부터 발생하기 때문에 별도로 분리해야 한다고 생각했ㅅ브니다. 그와 동시에, `Effective Java(조슈아 블로크 저)`의 1번 아이템 `생성자 대신 정적 팩토리 메소드를 고려하라` 를 참고하여, 랜덤과 사용자 입력으로부터 각각 생성할 수 있음을 확실히 명시하기 위하여, 기본 생성자가 아닌 static 메소드를 활용하였습니다.  
이와 더불어, 다른 개발자가 `BallNumberSetFactory`의 존재를 알아야 생성할 수 있다는 점을 해결하기 위해, `BallNumberSet`에서 public 메소드를 만든 뒤, `BallNumberSetFactory`의 protected 생성 메소드를 호출할 수 있도록 하였습니다.

마지막으로, `BallNumberSet`이 유효한 입력으로부터 생성되는지 확인하기 위해, 검증 객체를 따로 분리하였습니다.

이러한 과정을 통해 해당 객체에게 "숫자를 생성하라" 라는 메시지의 전달만으로 그 이면에서 발생하는 일을 적절하게 숨기고자 하였고, 또 검증로직의 추가/삭제, 생성과정의 변화가 생길지라도 `BallNumberSet` 을 사용하는 입장에서 차이를 알 수 없도록 하고자 하였습니다.


## View Layer

게임을 진행하는 과정이 현재는 콘솔 기반으로 이루어지지만, 만약 웹을 기반으로, 혹은 윈도우 프로그램을 기준으로 진행되도록 변경된다면 어떨까? 라는 생각이 들었습니다.

따라서, View 인터페이스를 생성한 뒤, 제공되는 Console API를 감싸서 해당 인터페이스를 구현하는 ConsoleView 클래스를 생성하였습니다. 

## Game <-> Round

Game 또한 View와 마찬가지로, 마치 닌텐도에서 게임팩을 교체하듯이 Game을 교체할 수 있다면 어떨까? 라는 가정을 기반으로 구현하였습니다.

이에 따라, Application은 AppConfig 를 기반으로 게임을 실행하는 책임을 할당하였습니다.  

다음으로 게임은 다음의 두 가지의 맥락이 존재한다고 판단했습니다. 
1. 게임을 실행하고, 종료하는 등의 컨트롤러
2. 실제 게임이 진행되면서 로직에 따라 게임을 즐기는 서비스

그에 따라 `Game`의 경우, 실제로 게임을 실행하고, 종료되었을 경우 사용자에게 재시작 여부를 묻는, `게임의 실행 흐름`과 관련한 책임을 할당하고자 하였습니다. 반면 `Round` 객체는 사용자가 게임을 즐기는 로직, 즉 `게임 로직`을 관리하는 책임을 제공하고자 하였습니다.


